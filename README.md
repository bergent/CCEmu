# О проекте
Настоящий проект представляет собой эмуляцию работы **центра обработки вызовов** (ЦОВ/CallCenter). Проект выполнен
в рамках обучения в **IT-школе НТЦ Протей**.

## Cборка
Для сборки предлагается использование **CMake**. 

```sh
$ git clone https://github.com/bergent/CCEmu.git
$ mkdir ./CCEmu/build && cd ./CCEmu/build
$ cmake ..
$ cmake --build .
```

P.S. Сборка может занять достаточно много времени т.к. происходит подгрузка и сборка библиотек с помощью `FetchContent` из CMake

# Описание программы
Проект представляет из себя клиент-серверное приложение. 

Для запуска приложения в режиме **клиента** воспользуйтесь следующей командой:

```sh
$ ./CCEmu client
```

Для запуска приложения в режиме **сервера** воспользуйтесь следующей командой:

```sh
$ ./CCEmu server
```


## Конфигурация приложения

Конфигурация приложения осуществляется путём редактирования файла `config.json`, находящегося в корневой папке проекта.

Пример `config.json`:

```json
{
    "debug_log": 0,

    "client": 
    {
        "port": 8080,
        "host": "localhost"
    },

    "server":
    {
        "port": 8080,
        "host": "localhost"
    },

   "callcenter":
   {
        "num_operators": 2,
        "queue_max_size": 2,
        "min_queue_time": 20000,
        "max_queue_time": 30000,
        "queue_refresh_time": 3000,
        "min_call_time" : 15000,
        "max_call_time" : 30000,
        "same_number_policy": "warning"
   }
}
```

Описание полей:

- `debug_log` - включить/отключить отладочные сообщения в логах (`0` - выключить, `1` - включить)
- `client` - поля, относящиеся к параметрам клиента
  - `port` - порт сервера, к которому будут отправляться запросы
  - `host` - хост сервера, к которому будут отправляться запросы
- `server` - поля, относящиеся к параметрам сервера
   - `port` - порт сервера
   - `host` - хост сервера
- `callcenter` - поля, относящиеся к параметрам сервера
  - `num_operators` - максимальное количество операторов
  - `queue_max_size` - максимальный размер очереди входящих звонков
  - `min_queue_time` - минимальное время ожидание в очереди входящих звонков, в милисекундах
  - `max_queue_time` - максимальное время ожидание в очереди входящих звонков, в милисекундах
  - `queue_refresh_time` - время, показывающее частоту обновления очереди входящих звонков, в милисекундах
  - `min_call_time` - минимальная продолжительность разговора с оператором, в милисекундах
  - `max_call_time` - максимальная продолжительность разговора с оператором, в милисекундах
  - `same_number_policy` - поведение ЦОВ в случае дублирования входящего вызова **(реализован только `warning`)**

## Клиент

Со стороны клиента с помощью консольного ввода предлагается ввести запрос в виде номера телефона формата `[+][7-8]xxxxxxxxxx`.

Пример корректного запроса: `+74012805805`

При корректном запросе и работающем сервере, клиент получит HTTP-ответ от сервера, содержащий `CallID` и статус вызова.

Клиент может получить следующие статусы вызова:

- `OK` - звонок был успешно перенаправлен на оператора
- `Queued` - звонок был отправлен в очередь
- `Overload` - звонок был отклонен по причине переполнения очереди звонков
- `Duplication` - звонок был отклонен по причине дублирования вызова т.е. данный вызов либо находится в очереди, либо уже связан с оператором
- `Undefined Error` - звонок был отклонен по причине непредвиденной ошибки

В случае некорректного ввода или невозможности установить соединение с сервером клиент отобразит в консоли предупреждение.

В качестве клиента также можно использовать иные способы отправления HTTP-запросов, например _браузер_.

## Сервер

Со стороны сервера принимаются HTTP-запросы формата `http://host:port/[+][7-8]xxxxxxxxxx`.

Пример корректного запроса: `http://localhost:8080/+74012805805`

В случае получения корректного запроса, сервер отправляет HTTP-ответ клиенту содержащий уникальный ID входящего вызова и один из вариантов статуса звонка, описанных ранее, и выполняет эмуляцию работы центра обработки вызова.

Для выполнения логики работы центра обработки вызова, в реализации использованы следующие сущности:

- `CallCenter` - основной класс, функционал которого заключается в обработке поступающих вызовов и управлении операторами.
- `Call` - класс, хранящий всю информацию о вызове: номер телефона, ID, временные отметки, статус вызова.
- `Operator` - класс оператора, выполняющий имитацию разговора с абонентом и взаимодействующий с центром обработки вызовов.

По результатам работы эмулятора в корневой папке проекта формируется файл `cdr.txt` содержащий в себе информацию о каждом входящем вызове. Данный файл содержит следующие поля:

- `IncomingDT` - дата и время поступления вызова.
- `CallID` - уникальный идентификатор вызова.
- `CgPN` - номер телефона входящего вызова
- `ReleaseDT` - дата и время окончания вызова.
- `Status` - статус вызов.
- `ResponseDT` - дата и время соединения с оператором (пустое поле, если соединения не было)
- `OperatorID` - уникальный идентификатор оператора (`-1`, если соединения не было)
- `CallDuration` - продолжительность разговора с оператором (`0`, если соединения не было)

Дата и время выводятся в формате `YYYY-MM-DD HH24:MM:SS.ffffff`

Возможные статусы вызова:

- `OK` - вызов успешно закончен
- `Overload` - вызов отклонен по причине переполнения очереди звонков
- `Duplication` - вызов отклонен по причине дублирования вызова
- `Timeout` - вызов отклонен по причине превышения времени ожидания в очереди
- `Error` - вызов отклонен по причине непредвиденной ошибки

## Тестирование

Тестирование реализовано с помощью gtest. 

Для запуска автотестов предлагается воспользоваться **CTest**

```sh
$ pwd
/path/to/CCEmu/build
$ ctest
```

Или напрямую запустить исполняемый файл:

```sh
$ pwd
/path/to/CCEmu/build
$ ./CCEmuTest
```

На текущий момент реализовано тестирование классов `Call` и `Randomizer`

<br>

Для проведения "ручного" тестирования работы программы также был разработан скрипт на **Python**.

Суть скрипта заключается в том, что он рандомно генерирует номера телефонов и отправляет GET-запрос на сервер.

Скрипт **НЕ** запускает сервер. Поэтому подразумевается, что приложение в режиме сервера уже запущено.

Чтобы воспользоваться скриптом предлагается выполнить следующие действия:

```sh
$ pwd
/path/to/CCEmu/tests
$ pip install -r requirments.txt
$ python3 cctest.py 10 1000
```

<br>

Синтаксис вызова скрипта:

```sh
$ python3 cctest.py [num_requests] [delay_ms]
```

- `num_requests` - количество отправляемых запросов (целое число)
- `delay_ms` - задержка между запросами, в милисекундах (целое число)

Скрипт будет выводить в консоль информацию о том, какой запрос он отправил и какой ответ от сервера был получен.

## Использованные библиотеки

В проекте были использованы сторонние библиотеки для реализации функционала

- [cpp-httplib](https://github.com/yhirose/cpp-httplib) - использована для реализации взаимодействия между клиентом и сервером по протоколу HTTP.
- [nlohmann/json](https://github.com/nlohmann/json) - использована для реализации парсинга JSON файла с конфигурацией.
- [spdlog](https://github.com/gabime/spdlog) - использована для реализации логирования.
- [uuid_v4](https://github.com/crashoz/uuid_v4) - использована для генерации уникальных идентификаторов формата UUIDv4.
- [boost](https://www.boost.org/) - использована для работы с датой и временем.
- [gtest/gmock](https://github.com/google/googletest) - фреймворк для создания юнит-тестов

## Что стоило бы улучшить, но не хватило времени/навыков

- Рефакторинг кода. Многие вещи были написаны в спешке. Из наиболее очевидных задач рефакторинга - использование наследования для классов `Server`, `Client` и `CallCenter` так как они обладают схожим функционалом (считывают параметры из JSON'а и подключают логгер).
- Функционал альтернативной обработки дублированных входящих вызовов (перенос в начало очереди вместо сброса вызова).
- Функционал обновления параметров приложения в runtime.
- Реализация сбора статистики.
- Тестирование...


